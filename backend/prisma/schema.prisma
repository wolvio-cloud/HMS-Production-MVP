// HMS Production MVP - Database Schema
// Focused on Doctor Console with General/Specialist workflow

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============ USER & AUTHENTICATION ============

model User {
  id        String   @id @default(cuid())
  username  String   @unique
  password  String   // bcrypt hashed
  name      String
  role      UserRole

  // Doctor-specific fields
  specialty DoctorSpecialty?

  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  patientsAssigned  Patient[] @relation("AssignedDoctor")
  vitalsRecorded    Vitals[]  @relation("VitalsRecordedBy")
  prescriptions     Prescription[] @relation("PrescribedBy")
  labOrders         LabOrder[] @relation("OrderedBy")

  @@map("users")
}

enum UserRole {
  ADMIN
  RECEPTIONIST
  NURSE
  DOCTOR
  LAB_TECH
  PHARMACIST
  BILLING
}

enum DoctorSpecialty {
  GENERAL           // Shared queue
  ORTHOPEDIC        // Assigned queue
  CARDIOLOGY        // Assigned queue
  GYNECOLOGY        // Assigned queue
  ENT               // Assigned queue
  DERMATOLOGY       // Assigned queue
  PEDIATRIC         // Assigned queue
}

// ============ PATIENT & WORKFLOW ============

model Patient {
  id        String        @id @default(cuid())
  token     Int           @unique // Daily token number
  uhid      String        @unique // Unique Hospital ID (permanent)

  // Demographics
  name      String
  age       Int
  gender    Gender
  mobile    String
  address   String?

  // Workflow State
  stage              PatientStage  @default(VITALS_PENDING)
  status             PatientStatus @default(IN_PROGRESS)
  consultationType   DoctorSpecialty @default(GENERAL)

  // Doctor Assignment
  doctorId           String?
  doctor             User?   @relation("AssignedDoctor", fields: [doctorId], references: [id])

  // Timestamps
  registeredAt  DateTime   @default(now())
  completedAt   DateTime?

  // Relations
  vitals         Vitals?
  prescriptions  Prescription[]
  labOrders      LabOrder[]
  stateHistory   PatientStateHistory[]
  visits         Visit[]    // Patient can have multiple visits (encounters)

  @@index([stage, status, doctorId])
  @@index([stage, status, consultationType])
  @@map("patients")
}

enum Gender {
  M
  F
  OTHER
}

enum PatientStage {
  REGISTERED
  VITALS_PENDING
  DOCTOR_PENDING
  LAB_PENDING
  DOCTOR_REVIEW_PENDING
  PHARMACY_PENDING
  BILLING_PENDING
  COMPLETED
}

enum PatientStatus {
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

// ============ VITALS ============

model Vitals {
  id            String   @id @default(cuid())
  patientId     String   @unique
  patient       Patient  @relation(fields: [patientId], references: [id], onDelete: Cascade)

  // Vital Signs
  bp            String   // "120/80"
  pulse         Int
  temperature   Float
  spo2          Int
  height        Float    // cm
  weight        Float    // kg
  bmi           Float    // Auto-calculated

  // Clinical Info
  chiefComplaint String
  allergies      String?  // Comma-separated

  // Metadata
  recordedById  String?
  recordedBy    User?    @relation("VitalsRecordedBy", fields: [recordedById], references: [id])
  recordedAt    DateTime @default(now())

  @@map("vitals")
}

// ============ MEDICINES & STOCK ============

model Medicine {
  id            String   @id @default(cuid())
  name          String   @unique
  genericName   String?
  type          String   // Tablet, Syrup, Injection
  strength      String   // 500mg, 10ml

  // Pricing
  mrp           Float
  sellingPrice  Float

  // Stock (denormalized for quick access)
  currentStock  Int      @default(0)
  reorderLevel  Int      @default(10)

  isActive      Boolean  @default(true)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relations
  stockBatches      MedicineStock[]
  prescriptionItems PrescriptionItem[]

  @@index([name])
  @@map("medicines")
}

model MedicineStock {
  id            String   @id @default(cuid())
  medicineId    String
  medicine      Medicine @relation(fields: [medicineId], references: [id], onDelete: Cascade)

  batchNumber   String
  quantity      Int
  expiryDate    DateTime

  createdAt     DateTime @default(now())

  @@unique([medicineId, batchNumber])
  @@index([medicineId, expiryDate])
  @@map("medicine_stock")
}

// ============ PRESCRIPTION ============

model Prescription {
  id          String   @id @default(cuid())
  patientId   String
  patient     Patient  @relation(fields: [patientId], references: [id], onDelete: Cascade)

  doctorId    String
  doctor      User     @relation("PrescribedBy", fields: [doctorId], references: [id])

  diagnosis   String?
  notes       String?

  items       PrescriptionItem[]

  createdAt   DateTime @default(now())
  dispensedAt DateTime?

  @@index([patientId])
  @@map("prescriptions")
}

model PrescriptionItem {
  id             String       @id @default(cuid())
  prescriptionId String
  prescription   Prescription @relation(fields: [prescriptionId], references: [id], onDelete: Cascade)

  medicineId     String
  medicine       Medicine     @relation(fields: [medicineId], references: [id])

  dosage         String       // "1-0-1"
  duration       Int          // days
  quantity       Int          // auto-calculated
  instructions   String?      // "After food"

  dispensed      Boolean      @default(false)

  @@map("prescription_items")
}

// ============ LAB TESTS ============

model LabTest {
  id          String   @id @default(cuid())
  name        String   @unique
  category    String   // Hematology, Biochemistry
  price       Float
  sampleType  String   // Blood, Urine
  tat         Int      // Turnaround time (minutes)

  orders      LabOrder[]

  @@map("lab_tests")
}

model LabOrder {
  id         String    @id @default(cuid())
  patientId  String
  patient    Patient   @relation(fields: [patientId], references: [id], onDelete: Cascade)

  testId     String
  test       LabTest   @relation(fields: [testId], references: [id])

  doctorId   String
  doctor     User      @relation("OrderedBy", fields: [doctorId], references: [id])

  sampleId   String?   @unique
  status     LabStatus @default(PENDING)

  orderedAt  DateTime  @default(now())
  collectedAt DateTime?
  completedAt DateTime?

  @@index([patientId, status])
  @@map("lab_orders")
}

enum LabStatus {
  PENDING
  COLLECTED
  IN_PROGRESS
  COMPLETED
}

// ============ AUDIT TRAIL ============

model PatientStateHistory {
  id         String       @id @default(cuid())
  patientId  String
  patient    Patient      @relation(fields: [patientId], references: [id], onDelete: Cascade)

  fromStage  PatientStage?
  toStage    PatientStage

  performedBy String?     // User ID
  reason      String?

  timestamp  DateTime     @default(now())

  @@index([patientId, timestamp])
  @@map("patient_state_history")
}

// ============ VISIT & BILLING (SPRINT 1) ============

// Visit: Central encounter tracking - replaces ad-hoc queue logic
model Visit {
  id        String      @id @default(cuid())
  patientId String
  patient   Patient     @relation(fields: [patientId], references: [id], onDelete: Cascade)

  visitType VisitType   @default(OPD)

  // Timestamps
  arrivedAt   DateTime  @default(now())
  completedAt DateTime?

  // Relations to all services consumed during this visit
  billings    Billing[]

  @@index([patientId, arrivedAt])
  @@map("visits")
}

enum VisitType {
  OPD           // Out-patient
  IPD           // In-patient (future)
  EMERGENCY     // Emergency (future)
}

// Billing: Bill header with totals
model Billing {
  id       String       @id @default(cuid())
  visitId  String
  visit    Visit        @relation(fields: [visitId], references: [id], onDelete: Cascade)

  // Billing info
  billNumber String      @unique // Auto-generated: HMS/2024/0001

  // Financial Summary
  subtotal   Float       // Sum of all line items (before tax)
  taxAmount  Float       // Total tax (GST)
  discount   Float       @default(0)
  total      Float       // Final amount to pay
  balance    Float       // Outstanding amount (total - paid)

  status     BillingStatus @default(PENDING)

  // Audit
  generatedBy String?    // User ID who generated bill
  generatedAt DateTime   @default(now())
  paidAt      DateTime?

  // Relations
  items            BillingItem[]
  payments         Payment[]
  creditBilling    CreditBilling?    // Optional: Only for insurance bills
  refunds          Refund[]          // Can have multiple refund requests
  discounts        Discount[]        // Can have multiple discount requests
  outstandingBill  OutstandingBill?  // Optional: Only if unpaid

  @@index([visitId])
  @@index([billNumber])
  @@index([status])
  @@map("billings")
}

enum BillingStatus {
  PENDING       // Generated but not paid
  PARTIAL       // Partially paid
  PAID          // Fully paid
  CANCELLED     // Cancelled
}

// BillingItem: Line items with tax logic
model BillingItem {
  id         String   @id @default(cuid())
  billingId  String
  billing    Billing  @relation(fields: [billingId], references: [id], onDelete: Cascade)

  // Item details
  itemType   BillingItemType
  itemId     String?  // Reference to Prescription/LabOrder/etc (optional)
  description String  // "Paracetamol 500mg", "CBC Test", "Consultation Fee"

  // Pricing
  quantity   Int      @default(1)
  unitPrice  Float    // Price per unit
  amount     Float    // quantity Ã— unitPrice

  // Tax logic (CRITICAL for India GST)
  isTaxInclusive Boolean @default(false)  // TRUE for Pharmacy MRP, FALSE for Services
  taxRate        Float   @default(0)      // 12% for medicines, 18% for services
  taxAmount      Float   @default(0)      // Calculated tax

  total      Float    // Final line total (amount + tax if exclusive, amount if inclusive)

  @@index([billingId])
  @@map("billing_items")
}

enum BillingItemType {
  CONSULTATION   // Doctor consultation fee
  MEDICINE       // Pharmacy items
  LAB_TEST       // Lab investigations
  PROCEDURE      // Medical procedures (future)
  BED_CHARGES    // IPD bed charges (future)
}

// Payment: Track all payments for a bill
model Payment {
  id         String      @id @default(cuid())
  billingId  String
  billing    Billing     @relation(fields: [billingId], references: [id], onDelete: Cascade)

  amount     Float
  mode       PaymentMode

  // Payment details
  transactionId String?  // For UPI/Card/Razorpay
  upiId         String?  // For UPI payments
  cardLast4     String?  // For card payments

  // Razorpay integration
  razorpayOrderId   String?  // Razorpay order ID
  razorpayPaymentId String?  // Razorpay payment ID
  razorpaySignature String?  // Razorpay signature for verification

  status     PaymentStatus @default(PENDING)

  // Audit
  recordedBy String?    // User ID who recorded payment
  recordedAt DateTime   @default(now())
  remarks    String?

  @@index([billingId])
  @@index([transactionId])
  @@map("payments")
}

enum PaymentMode {
  CASH
  CARD
  UPI
  RAZORPAY_LINK  // Payment link sent to patient
  INSURANCE      // TPA/Insurance (future)
}

enum PaymentStatus {
  PENDING        // Payment initiated
  SUCCESS        // Payment successful
  FAILED         // Payment failed
  REFUNDED       // Payment refunded
}

// ============ BILLING EXTENDED (SPRINT 1) ============

// CreditBilling: Insurance/TPA billing tracking
model CreditBilling {
  id         String   @id @default(cuid())
  billingId  String   @unique
  billing    Billing  @relation(fields: [billingId], references: [id], onDelete: Cascade)

  // Insurance/TPA Details
  insuranceProvider String   // "ICICI Lombard", "Star Health"
  policyNumber      String
  claimNumber       String?  // TPA claim number

  // Approval Details
  approvalCode      String?  // Pre-authorization code
  approvedAmount    Float?   // Amount approved by TPA
  patientShare      Float?   // Co-pay amount (patient pays)
  insuranceShare    Float?   // Amount to be claimed from insurance

  status            CreditStatus @default(PENDING)

  // Audit
  submittedAt       DateTime?
  approvedAt        DateTime?
  settledAt         DateTime?
  remarks           String?

  @@index([billingId])
  @@index([claimNumber])
  @@map("credit_billings")
}

enum CreditStatus {
  PENDING           // Submitted to TPA
  APPROVED          // TPA approved
  PARTIALLY_APPROVED // Partial approval
  REJECTED          // TPA rejected
  SETTLED           // Payment received from TPA
}

// Refund: Refund approval workflow
model Refund {
  id         String      @id @default(cuid())
  billingId  String
  billing    Billing     @relation(fields: [billingId], references: [id], onDelete: Cascade)

  paymentId  String?     // Original payment being refunded

  amount     Float       // Refund amount
  reason     String      // "Cancelled appointment", "Duplicate payment"

  status     RefundStatus @default(PENDING)

  // Approval Workflow
  requestedBy   String    // User ID who requested
  requestedAt   DateTime  @default(now())

  approvedBy    String?   // Manager/Admin who approved
  approvedAt    DateTime?

  processedBy   String?   // Billing staff who processed
  processedAt   DateTime?

  rejectionReason String?

  @@index([billingId])
  @@index([status])
  @@map("refunds")
}

enum RefundStatus {
  PENDING       // Awaiting approval
  APPROVED      // Manager approved
  REJECTED      // Manager rejected
  PROCESSED     // Refund completed
}

// Discount: Manager-approved discounts
model Discount {
  id         String   @id @default(cuid())
  billingId  String
  billing    Billing  @relation(fields: [billingId], references: [id], onDelete: Cascade)

  discountType   DiscountType
  amount         Float        // Discount amount
  percentage     Float?       // Discount percentage (if applicable)

  reason         String       // "Senior citizen", "Staff family", "CSR"

  status         DiscountStatus @default(PENDING)

  // Approval Workflow
  requestedBy    String       // Billing staff who requested
  requestedAt    DateTime     @default(now())

  approvedBy     String?      // Manager who approved
  approvedAt     DateTime?

  rejectionReason String?

  @@index([billingId])
  @@index([status])
  @@map("discounts")
}

enum DiscountType {
  FLAT          // Flat amount discount
  PERCENTAGE    // Percentage-based discount
  SENIOR_CITIZEN // Senior citizen discount
  STAFF         // Staff/employee discount
  CSR           // Corporate social responsibility
}

enum DiscountStatus {
  PENDING       // Awaiting approval
  APPROVED      // Manager approved
  REJECTED      // Manager rejected
}

// OutstandingBill: Track unpaid dues
model OutstandingBill {
  id         String   @id @default(cuid())
  billingId  String   @unique
  billing    Billing  @relation(fields: [billingId], references: [id], onDelete: Cascade)

  patientId  String   // For easy querying of patient dues

  outstandingAmount Float  // Balance amount
  dueDate           DateTime?

  // Follow-up tracking
  lastFollowUpDate  DateTime?
  nextFollowUpDate  DateTime?
  followUpNotes     String?

  status            OutstandingStatus @default(ACTIVE)

  // Audit
  createdAt         DateTime @default(now())
  settledAt         DateTime?

  @@index([billingId])
  @@index([patientId])
  @@index([status])
  @@map("outstanding_bills")
}

enum OutstandingStatus {
  ACTIVE        // Has outstanding balance
  PARTIAL       // Partially paid
  SETTLED       // Fully paid
  WRITTEN_OFF   // Bad debt written off
}
